### 들어가며

안녕하세요 오늘은 대표적인 자료구조 중 하나며 구현이 꽤나 복잡한 자료구조인 Tree 에 대해서 학습하겠습니다. 사실 Tree 라고 개념을 잡으면 Tree에는 너무 종류가 많아서 모두 알아보기엔 무리가 있다고 판단이 되고요.  Tree 중 가장 알고리즘 문제에 많이 나오고 유용한 **"이진 트리"** 에 대해서 오늘은 정리할 예정 입니다.  이진 트리는 다른 말로 BST (Binary Search Tree) 라고도 하는데 앞으로의 스터디에서 두 가지 용어가 혼용될 수 있으니 알아두시면 좋을거 같습니다.

<br>

### Tree 구조

먼저 Tree 구조를 알아보겠습니다. 트리란 "Node 와 Branch 를 이용해서, 사이클을 이루지 않도록 구성한 데이터 구조 입니다.

<br>

![](https://images.velog.io/images/somday/post/661cd51f-2022-47d7-9a53-b32ed4b41491/1.png)


<br>

위와 같은 구조가 되면 Tree 라고 할 수 없습니다.

Tree 의 용도는 주로 이진 트리를 이용해서 탐색 알고리즘에 가장 많이 사용됩니다. 깊이 우선 탐색, 너비 우선 탐색 등등이 대표적인 사례 입니다.

<br>

### 이진 탐색 트리

위에서 제가 이진 트리 (Binary Tree) 를 이진 탐색 트리 (Binary Search Tree) 라고도 한다고 했습니다. 하지만 이는 정확한 정보는 아닙니다. 하지만 보통 이진 트리를 사용한다고 하면 이진 탐색 트리를 많이 생각하기 때문에 둘의 차이점만 인지한 상태에서 단어 사용은 크게 상관은 없습니다. 그렇다면 정확한 차이는 무엇일까요???

<br>

**차이점**

- 이진 트리: 노드의 최대 Branch 가 2개인 트리
- 이진 탐색 트리: 이진 트리에 특정 조건이 추가된 트리 구조
    - ex) "기준 노드의 value 보다 작은 value 를 가진 Node 는 왼쪽으로 정렬, 기준 노드의 value 보다 큰 value 를 가진 노드는 우측 정렬 " 와 같은  조건을 가지게 되면 이진 탐색 트리가 라고 할 수 있습니다.

*예시*

![](https://images.velog.io/images/somday/post/5d0f212b-0212-4691-9d2e-38042838a3d9/2.png)


<br>

그림이 이쁘지는 않지만 대표적인 이진 탐색 트리의 구조이 입니다. 이진 탐색 트리의 모형은 구글에 검색해보시면 더 욱 많은 정보를 얻을 수 있으니 검색해보시는 것을 추천 드립니다.


<br>

### 이진 탐색 트리의 장점

그렇다면 이진 탐색 트리의 장점은 무엇이길레 검색 알고리즘에서 많이 사용 될까요??  **가장 큰 장점은 역시나 탐색 속도가 개선될 수 있다는 점 입니다.**

기존의 배열을 생각하면 정렬되지 않은 경우이든 정렬된 경우이든 최소한 N 번의 탐색이 필요합니다. 반면 이진 탐색 트리는 특정 조건에 따라 정렬 되며 데이터가 저장되며 이 조건에 따라 1회 검색당 절반이 검색 대상에서 제외 되기 때문에 logN 의 시간 복잡도로 개선이 됩니다. 따라서 검색 속도가 아주 개선이 되었다고 볼 수 있습니다.

<br>

### 단점

단점이라고 하면 구현이 복잡할 수도 있다는 것과 최악의 경우에 기존의 배열을 사용하는 것과 동일한 성능을 가지게 되는데요 이러한 점이 단점 입니다. 여기서 최악의 경우란 데이터 입력이 1,2,3,4,5,6 혹은 5,4,3,2,1 이렇게 순차적으로 입력이 되어 아래와 같은 구조를 이루게 될 때 특정 노드를 탐색할 때 N 번 검색을 하게 되는 경우를 말합니다.

![](https://images.velog.io/images/somday/post/a6d49779-b727-440f-80a7-453dc1e87cce/3.png)


<br>

### 구현하기

- 이제 실제 구현을 해보겠습니다. 노드를 관리하는 클래스와 노드 클래스를 분리하여 구현을 합니다.

<br>

**Node 클래스**

![](https://images.velog.io/images/somday/post/aa390e5b-b341-4c50-96c8-858437c4ddb5/4.png)


노드 클래스의 구조는 간단합니다. 이진 탐색 트리의 노드는 기본적으로 left node, right node 를 가질 수 있고 Data 를 가질 수 있기 때문에 위와 같은 구조로 class 를 정의했습니다. 다음으로 NodeMgnt 클래스를 만들어서 노드를 관리하여 이진 탐색 트리를 구현하겠습니다.

<br>

**NodeMgnt 클래스**

![](https://images.velog.io/images/somday/post/ba6f7e9a-89d4-4be9-b786-7d794896a586/5.png)


<br>

**살펴보기**

우선은 새로운 노드 추가와, 노드 탐색을 구현했습니다.  추가와 탐색은 그나마 간단한 편입니다.

- 먼저 추가 로직 부터 살펴보면 먼저 head가 null 인지 검사를 하고 null 일 경우 head를 추가합니다.
- head 가 null 이 아니라면 Node 가 있는 것이기 때문에 이진 탐색 트리 조건에 맞게 입력 데이터가 현재 Node의 Data 보다 큰지 작은 지 판단 후 왼쪽 오른쪽  방향을 결정합니다.  이 과정을 조건이 성립할 때까지 반복해야 하기 때문에 while (true) 통해 조건이 맞아 떨어지고 새로운 노드를 생성 할때 까지 반복하게 됩니다.

다음은 노드 탐색 로직을 보겠습니다. 이도 크게 어려운 것은 없습니다.

- 먼저 head 가 null 인지 체크합니다 head 가 null 이면 생성된 Node가 하나도 없는 것이기 때문에 null 을 반환하고 끝이 납니다.
- head 가 null 이 아니라면 이제 본격적인 탐색을 합니다. 이때 findNode 가 null 이 아닐 때까지 반복을 하는데요 즉, 트리의 Depth 의 끝까지 탐색을 해보겠다는 의미가 됩니다.
- 여기서 조건 분기를 해서 왼쪽으로 탐색을 할지 우측으로 탐색을 할지 if 문을 통해서 분기처리를 한 뒤 찾는 데이터가 있다면 끝까지 탐색하지 않고 결과를 return 합니다.
- 만약 끝까지 탐색을 했지만 원하는 Data 가 없다면 null 을 리턴하고 종료 하게 됩니다.

"이제 다음으로는 삭제 로직을 살펴봐야 하는데요 삭제는 경우의 수가 많기 때문에 따로 분리하여 경우의 수를 생각해보겠습니다."

<br>

### 삭제 구현하기

삭제의 경우는 다음과 같은 경우의 수들이 있습니다.

- 삭제 node 가 leaf_node 인 경우
- 삭제 node 의 자식 node가 한 개인 경우
- 삭제 node 의 자식 노드가  두 개인 경우

크게 이렇게 나눌 수 있지만 각각의 경우의 에서도 또 경우의 수가 존재하기 때문에 하나하나 대응해보록 하겠습니다.

<br>

**삭제 node 가 leaf_node 인 경우**

- 삭제 코드의 경우 구현 코드가 너무 길기 때문에 일부 코드만 따로 따로 보겠습니다.
- 우선 leaf_node 는 최하단의 node 로 더 이상 자식 노드가 없는 node 를 의미합니다.
- leaf_node 인 경우는 단순히 부모 노드의 left 혹은 right 를 null 로 만들면 연결이 끊어 지기 때문에 간단하게 구현할 수 있습니다.

<br>

**leaf_node 그림**

![](https://images.velog.io/images/somday/post/d9850257-678c-4af6-962b-3c36a6cb34ab/6.png)


<br>

**구현 코드**

![](https://images.velog.io/images/somday/post/8c8d1da0-c13e-42fa-9cd0-118e8cbbbdc0/7.png)


삭제 할 노드의 자식의 노드가 한 개인 경우

- 이 때도 자식의 노드가 왼쪽에 있냐 오른쪽에 있냐를 검사해야 합니다.
- 만약 삭제할 node 가 왼쪽에 있고 이 node 의 자식 노드가 왼쪽에 있다면 ParentNode.left 에 삭제할 node 의 왼쪽 node 를 할당합니다.
- 추가적으로 node가 왼쪽에 있고 node 의 자식 노드가 우측에 있어도 ParentNode.left 에 삭제할 node.right 를 할당 하면 됩니다.

<br>

**구현 코드**

![](https://images.velog.io/images/somday/post/a931c9c8-8571-4b33-b4e2-d6af2fe59a3e/8.png)


**마지막으로 가장 복잡한 삭제할 node 의  자식 노드가 두 가지인 경우를 살펴보겠습니다.**

이 때 전략을 두 가지가 선택이 가능합니다.

- 삭제할 Node 의 우측 자식 중 가장 작은 값을 삭제할 Node 의 Parent Node가 가리키도록 한다.
- 삭제할 Node의 좌측 자식 중 가장 큰 값을 Node 의 Parent Node가 가리키도록 한다.

여기서는 가장 작은 값을 삭제할 Node ParentNode 에 할당하는 전략을 사용할 것입니다. 다만 여기서도 두 가지 경우의 수가 생깁니다.

- 삭제할 Node가 Parent Node 의 오른쪽에 있고, 삭제할 Node 의 오른쪽 자식 중, 가장 작은 값을 가진 Node 의 Child Node 가 없을 경우
- 삭제할 Node가 Parent Node의 오른쪽에 있고, 삭제할 Node 의 오른쪽 자식 중, 가장 작은 값을 가진 Node 의 오른쪽에 Child Node 가 있을 경우
  
<br>

![](https://images.velog.io/images/somday/post/b8def133-425d-4c2f-8ebb-798239ab556d/9.png)


<br>

**구현 코드**

![](https://images.velog.io/images/somday/post/8b7d2ccb-80db-4592-b4c2-c16526cf48b2/10.png)

<br>
<br>
<br>

### **회고**

이상으로 Tree 자료구조를 학습했습니다. Tree 는 삭제의 경우에 복잡한 케이스를 가지게 되는데 이녀석은 암기를 하는 편이 제일 좋은 해결 책인거 같습니다. 구현 함에 있어서 로직이 어려운 것이 아니라 경우의 수가 많기 때문에 어쩔 수 없는 부분인거 같습니다.

지금까지 구현한 코드가 최적화를 적용한 코드가 아니라서 더욱 더욱 보기 힘든 코드이기는 하지만 한 번 구현을 직접해봄으로 트리의 자료구조를 보다 잘 알게 된거 같습니다.

<br>
<br>
<br>

**감사합니다.**