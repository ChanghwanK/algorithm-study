### 완전탐색이란?

완전 탐색의 정확한 의미를 살펴보기전에 완전탐색을 사용하는 의도를 먼저 살펴보겠습니다. 코딩 테스트나 실생활 등에서 완전탐색을 이용하는 경우는 **"특정 경우의 수들 가운데 원하는 조건의 정답을 무조건 구할 때"** 사용하게 됩니다.

따라서  자원만 충분하다면 결국엔 무조건 정답을 구해주는 가장 확실한 알고리즘 입니다. 다만 하나부터 열까지 모든 것에 대해서 탐색하기 때문에 시간 복잡도와 공간 복잡도에 대한 어느정도 여유가 있을 때 사용하는 것이 바람직합니다.  보통 현재 컴퓨터의 연산이 초당 1억번 정도라고 생각하면 되는 것으로 알고있습니다. 따라서 그 이하의 시간복잡도를 가지는 경우 모두 완전 탐색을 사용하면 최적의 알고리즘은 아니지만 정답은 얻을 수 있기 때문에 **"부분 점수"를 얻기에 아주 좋습니다.**

<br>

### 완전탐색 기법

- Brute Force: For 문과 If 문을 이용해서 처음부터 끝까지 탐색하는 방법
- Back-Tracking
- 재귀 함수
- BFS, DFS 탐색

등이 있습니다.

<br>

### 코테에 나오는 완전 탐색의 종류

- N개 중 중복을 허용해서 M 개를 단순 선택해서 나열
- N개 중 중복을 허용해서 M 개를 순서 있게 나열
- N개 중 중복을 허용하지 않고  M 개를 단순 선택해서 나열
- N개 중 중복을 허용하지 않고  M 개를 순서 있게 나열


<br>

### 예시 문제

- N 개 중 중복을 허용해서 M개를 순서 있게 나열하기
- [BOJ 15651 - N 과 M (3)](https://www.acmicpc.net/problem/15651)
- 난이도 2

<br>

**정답 코드**

[링크](https://github.com/DevBloo/algorithm-study/blob/master/src/brute_force/Boj_15651.java)

<br>

**풀이**

먼저 접근을 할 때 사람이 어떻게 접근하는지 부터 생각합니다. 만약 N=4 이고 M = 3일 경우 1~4 사이의 숫자들 중 3개를 뽑는 데 이때 중복을 허용해서 오름차순 출력이 조건이기 때문에

모든 경우의 수는 "111, 112, 113, 114, 121, 122   ~   444 까지" 출력할 수 있다는 것을  알 수 있습니다. 이것을 이제 컴퓨터가 구현을 하기 위해서 **재귀 호출을 이용하여 이 문제를 풀이 합니다.**

이제 풀이 방식을 구했으니 풀이 방식의 시간복잡도가 과연 문제의 조건에 충족이 될 것인가를 확인할 필요가 있습니다. 이 문제에서는 1 ~ 7 이 N 과 M 의 범위 조건이기 때문에 모든 경우의 수는 7^7 이 되기 때문에 충분히 문제 풀이에 지장이 없는 O(N^M) 시간복잡도를 가지게 됩니다.  다음으로 공간복잡도는 M 개의 공간을 사용해서 표현하기 때문에 O(M) 의 복잡도를 가지게 됩니다.

main 함수를 보면 문제 풀이를 위한 특정 값을 입력 받는 input 과 실질적으로 문제를 해결해주는 rec_func() 코드로 나누어져있습니다. 이번 문제를 해당 풀이에서는 "재귀 호출" 을 이용하여 문제를 해결 했습니다.

따라서 rec_func(int k) 의 로직을 살펴보면 먼저 M 번을 반복하게 되는데 1회당 N까지의 숫자를 selected 배열에 담고 출력합니다. 출력에 있어서 아무런 조건이 존재하지 않기 때문에 단순히 M번 돌면서 반복마다 N까지 모두 출력해주기만 하면 되는 간단한 문제 입니다.