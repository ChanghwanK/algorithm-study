### 개요

저번 시간에는 배열의 개념을 조금 알아보았고, 왜 알고리즘에서 배열의 역할이 중요한지 알아보았습니다. 이 글이 자바의 문법적 개념을 다루는 글은 아니기 때문에 이번 시간에도 문법적 개념은 상당수 생략되어 있습니다.

**이번에는 조금더 배열관련 문제 해결에 익숙해지기 위해서 문제 풀이를 다양하게 해보겠습니다.**


<br>

### 연습문제 - 소수의 나열

단순히 소수를 판별하는 것은 간단합니다. 이중 for 문을 돌며 n % i == 0 인 조건을 걸어서 분기처리하고 조건에 만족 하지 않는 i 들은 소수가 됩니다. 간단하게 코드로 보겠습니다.

**N 이하의 소수 나열 코드**

![](https://images.velog.io/images/somday/post/1a2247bc-3cd2-42f3-8cd9-c2a2923706d6/1.png)

일단 이렇게 하면 문제는 해결이 됩니다. 이 풀이의 핵심인 num % i 여기서 과연 몇번이 일어날까요???  **"%"** 하는  횟수를 count 라는 count 라는 변수를 추가해서 확인해보겠습니다.

<br>

**결과 코드**

![](https://images.velog.io/images/somday/post/aa29dbd7-56b7-4b08-9821-1c787296cbc5/2.png)


결과를 보면 고작 100까지의 숫자중 소수를 판별하는 문제이지만 나눗셈 횟수는 총 1133 회를 하는 것을 확인할 수 있습니다. 제가 10000 까지 숫자일 경우는 몇번을 하는가 궁금해서 돌려봤을 때 78022 회나 나눗셈을 진행함을 확인할 수 있었습니다. 이는 좋은 시간 복잡도를 가진다고 볼 수 없습니다. 그래서 좀 더 최적화를 진행해보겠습니다.

<br>

### **코드 리펙토링**

![](https://images.velog.io/images/somday/post/d7b44c87-a9c0-48d1-9bad-b354a65367e8/3.png)

<br>

위에서는 100 까지의 소수를 찾았지만 이번에는 얼만큼 극적으로 줄어든지 확인을 하기 위해서 1000 까지 소수검사를 진행했습니다.

<br>

**결과**

![](https://images.velog.io/images/somday/post/4209d44c-20fa-4704-81e2-cfe753e12b59/4.png)


<br>

### **풀이**

여기서 핵심은  **"prime[i] * prime[i]" 입니다.**

**prime[i] * prime[i] 이 n 보다 작거나 같다면 일단 최소 제곱근을 가지기 때문에 거르고 봅니다. 따라서 여기서 일차적으로 소수가 아닌 숫자가 걸러집니다. 즉, 어떤 정수 n은 n의 제곱근 이하의 어떤 수로도 나누어떨어지지 않음을 말합니다.**

따라서 이때 n의 제곱근을 구하는 것보다는 제곱을 구하는 것이 훨씬 간단하고 빠르기 때문에 제곱을 구합니다. 그리고 이제 나눗셈의 횟수만 카운팅하는 것이 아니라 곱셈과 나눗셈 모두 count 하여 연산 횟수를 구하게 됩니다.

<br>
<br>

### 한 해의 경과 일 수를 계산하는 프로그램

이번에는 2차원 배열을 활용하는 문제를 한 번 해결 해보겠습니다. 예컨대 4월 15일 그 해의 몇번째 일인가를 알기 위해선 아래의 공식이 필요합니다.

> 1월의 일수 + 2월의 일 수 + 3월의 일 수 + 15

이것을 일반적으로 나타내면 m월 d일의 그 해 경과 일 수는 다음과 같이 됩니다.

> 1월, 2월, ..., m-1월의 일 수의 합 + d

그런데 여기서 주의할 것이 있습니다. 2월은 윤년이 존재하기 때문에 일수가 달라집니다. 따라서 평년의 각 달의 일수 와 윤년의 각 달의 일 수는 달라지게 되고 이는 2차원 배열로 표현할 수 있습니다.

<br>

**배열로 표현**

![](https://images.velog.io/images/somday/post/539d058a-38e6-4c7f-b3fa-ddb2d6791a69/5.png)


이제 문제를 해결하기 위해선 먼저 윤년을 판단하고 윤년이 아니라면 0번째 행을, 윤년이라면 1번째 행을 사용해서 일 수를 구할 것입니다.

<br>

**윤년판단 로직**

> 4로 나누어 떨어지면서 100으로도 나누어 떨어지며 혹은 400으로 나누어 떨어지는 년도 는 윤년입니다.

<br>

**이를 코드로 표현하면 다음과 같습니다.**

![](https://images.velog.io/images/somday/post/c3b90ea4-6297-4593-a97a-1816ff92b142/6.png)

<br>

**이제 전체코드를 보겠습니다.**

![](https://images.velog.io/images/somday/post/ead6c493-4b5e-4f47-bff3-cb7c9d69ab09/7.png)


<br>

### 결과

![](https://images.velog.io/images/somday/post/2539b270-36c2-4b3c-b26f-7050aeb116bc/8.png)

<br>
<br>

### **회고**

이번에는 배열을 활용해서 소수 판단과 y년 m월 d일이  몇번째 요일인지 알아보는 문제들을 해결해봤습니다. 솔직히 소수 판단에서 알고리즘 개선은 아직 백퍼센트 이해했다고 말하기는 어렵습니다. 하지만 이러한 문제들을 해결하면서 집중해야 할 것은 정확한 해결 코드 보다는 다양한 접근 방식, 내 코드가 **"Best Effort"** 인지 의심해보는 시각을 가지는 것 입니다. 그리고 마지막으로 시간 복잡도를 최적화 했지만 그 과정에서 많은 메모리를 소모 하기 때문에 공간 복잡도는 떨어진다는 점 입니다. 따라서 문제를 해결할 때 적절한 타협점을 찾는 것이 좋겠습니다.