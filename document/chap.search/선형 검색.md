### **들어가며**

안녕하세요 이번시간에는 데이터 집합에서 원하는 값을 가진 요소를 찾아내느 **"검색 알고리즘"** 에 대해 살펴보겠습니다. TMI 이지만 저는 개인적으로 검색 알고리즘에 관심이 많습니다. 실제 개발에 사용되는  여러가지 DB들은 어떤 알고리즘으로 만들어져 있는지 참 궁금하기도 하고 naver, google 등의 검색 엔진은 어떻게 구현되어 있는지도 궁금합니다.

**따라서 이러한 기본적인 검색 알고리즘 부터 차근차근 준비한다면 어느정도는 감을 잡을 수 있지 않을까요?? 그럼 이제 본격적으로 학습을 진행하겠습니다.**

<br>
<br>

### 검색과 키

검색에는 많은 예시가 있지만 저는 주소록을 검색한다고 한 번 가정해 보겠습니다. 주소록 검색을 하기 위해서는 다음과 같은 과정이 필요합니다.

1. 국적이 XX 인 사람을 찾는다.
2. 주소가 XXX시 XXX 구 XXX 인 사람을 찾는다.

위의 검색뿐만 아니라 어떤 검색을 하게 되더라도 특정 항목에 주목한다는 점은 '검색하기' 의 공통점 입니다. 이러한 검색을 위해 주목하는 항목을 우리는 "키" 라고 부르겠습니다.

국적을 검색하는 경우 "국적"이 "키" 가 됩니다. 반대로 XX 시 에 사는 사람을 찾는 다면 "키" 값은 XX 시 가 됩니다.

즉, 데이터가 단순히 정숫값이 아니라면 "키"는 데이터의 "일부" 입니다.

<br>
<br>

### 여러가지 검색 기법

검색 기법에는 여러가지 있습니다. 대표적으로 선형 검색, 이진 검색, 해시법 정도가 있으며 다른 자료구조들을 활용해서 다양하게 검색 알고리즘을 구현할 수 있습니다. 우선은 **선형 검색, 이진 검색, 해시법에 대해서 조금 더 알아보겠습니다.**

1. 선형 검색: 무작위로 늘어놓은 데이터 모임에서 검색을 수행합니다.
2. 이진 검색: 일정한 규칙으로 늘어놓은 데이터 모임에서 아주 빠른 검색을 수행합니다.
3. 해시법: 추가, 삭제가 자주 일어나는 데이터 모임에서 아주 빠른 검색을 수행합니다.  해시법에는 체인법과, 오픈 주소법 두 가지 방식이 있습니다.
    - 체인법: 같은 해시 값의 데이터를 선형 리스트로 연결하는 방법입니다.
    - 오픈 주소법: 데이터를 위한 해시 값이 충돌할 때 재해시하는 방법입니다.

**검색에 있어서 어떤 검색 기법을 사용할지 선택하는 것은 상당히 중요한 고민거리입니다. 만약에 그냥 단순히 데이터 집합에서 특정요소를 검색만 하는 경우라면 단순히 검색 시간이 짧은 것을 선택하는 것이 BEST 입니다. 하지만 데이터의 추가, 삭제가 빈번하게 일어나는 경우라면 검색 이외의 작업에 소모되는 비용을 종합적으로 평가하는 시각이 필요합니다.**

<br>
<br>

### 선형검색

지금부터는 많은 검색알고리즘 중 가장 기본인 **"선형 검색"** 에 대해서 보겠습니다. 선형 검색은 단순합니다. 배열이 있다면 원하는 키값을 갖는 요소를 만날 때까지 배열의 맨앞부터 순서대로 요소를 검색하는 알고리즘 입니다.

![](https://images.velog.io/images/somday/post/3a323297-1522-4e7a-a124-f8a4891c936b/1.png)

<br>

**위의 배열에서 값 2의 요소를 선형 검색하는 모습을 보겠습니다.**

<br>

![](https://images.velog.io/images/somday/post/894c81a2-8be5-4759-b391-2fbdbb2b568e/2.png)

<br>

**검색은 다음과 같이 진행됩니다.**

  a. 첫 번째 요소 6을 선택합니다. 원하는 값이 없습니다.

  b. 첫 번째 요소 4을 선택합니다. 원하는 값이 없습니다.

  c. 첫 번째 요소 2을 선택합니다. 원하는 값이 없습니다.

  d. 첫 번째 요소 2을 선택합니다. 원하는 값이 있습니다. 검색 성공!!

<br>
<br>

### 선형 검색 - **검색 실패**

위의 경우는 검색을 성공한 케이스 입니다. 하지만 주어진 배열에 항상 원하는 요소가 있다는 법은 없습니다. 따라서 배열의 맨 끝까지 요소 검사를 하지만 찾는 값이 없다면 검색은 실패하게 됩니다.

<br>

![](https://images.velog.io/images/somday/post/664e043d-6280-4071-8c1b-918b92c51cea/3.png)

<br>

성공의 예와 실패의 예를 보면 **배열 검색의 종료 조건은 총 2가지 임을 알수 있습니다** 다음 조건 중 하나라도 성립하면 검색을 종료 합니다.

<br>

**종료 조건**

> a. 검색할 값을 발견하지 못하고 배열의 끝을 지나간 경우
b. 검색할 값과 같은 요소를 발견한 경우

<br>
<br>

**여기서 a 의 경우는 검색에 실패하는 조건이며 b 의 경우는 검색 성공의 조건 입니다. 보통 배열의 요솟수가 N 개일 경우 조건 1,2 를 판단하는 횟수는 평균 N / 2 회 입니다.**

<br>
<br>

### 실습 코드

- 지금까지 학습 한 내용으로 선형검색을 구현 해보겠습니다.

먼저 가장 간단하게 while 문을 이용해서 약간은 복잡?? 하게 구현한 코드입니다.

**while**

![](https://images.velog.io/images/somday/post/fc9fc28e-0ae0-459a-879c-c8ecfb21227b/4.png)

<br>

위의 코드를 보면 조금 복잡하고 코드가 지저분해 보입니다. 그리고 최적화 된 코드도 아닙니다. 따라서 조금 리팩토링을 해보겠습니다.

<br>
<br>

### 리팩토링 하기

- 두 번째는 while 문이 아닌 확장 for 문을 이용하여 코드를 조금 개선했습니다.

![](https://images.velog.io/images/somday/post/92a1b00b-791f-4197-9581-076178c4b94b/5.png)

<br>

처음의 while 문을 이용한 것보다 훨씬 로직이 깔끔해졌습니다. 하지만 단순히 코드가 clean 해진 것이지 이 알고리즘이 최적화 된 알고리즘은 아닙니다. 선형검색은 종료 판단 조건이 2가지 입니다.

**따라서 종료 판단 조건을 1가지만 하도록 한다면 시간복잡도를 절반으로 개선할 수 있습니다. 이때 사용하는 것이" 보초법"  이라는 기법입니다.**

<br>
<br>

### **보초법**

선형 검색은 반복할 때마다 종료 조건 두 가지를 모두 판단하는데 단순한 판단이라고 볼 수도 있지만 배열의 크기가 1만 10만이 된다면 이 비용은 결코 무시할 수 없는 비용이 들어갑니다. 따라서 "보초법"을 이용해서 절반으로 판단 조건 검사를 낮추는 것이 최적화 라고 볼 수 있습니다.

보초법은 무조건 찾고자 하는 key 값을 배열의 맨 마지막에다 둠으로써 배열의 맨마지막까지 요소검사를 한다면 검색을 무조건 종료하도록 하면 간단하게 구현할 수 있습니다.

<br>

**실습 코드**

![](https://images.velog.io/images/somday/post/53b702ce-5c57-461a-b9b0-df3d4ccefb5a/6.png)

<br>
<br>

### **회고**

오늘은 **"검색 알고리즘"** 에서 가장 기본이 되는 선형 검색을 알아보았습니다. 선형 검색이 기본이라고 해서 절대 안좋은 알고리즘?? 이라는 것은 아닙니다. 단순히 검색을 하고 제한 시간이 여유가 있다면 적극적으로 사용해서 문제를 해결 하면 좋습니다.

오늘은 문제를 풀어보지는 않았지만 코드 구현이 곧 문제가 되는 경우라고 생각합니다. 배열을 던져주고 여기서 key가 있는지 검사하는 것 자체가 일종의 문제인 것이지요. 다음시간에는 또 다른 검색 알고리즘인 **"이진 검색**" 을 학습하겠습니다.